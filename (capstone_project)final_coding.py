# -*- coding: utf-8 -*-
"""(Capstone_Project)Final Coding.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ah7epi0910YBy9A3yZBEyfZDe3-czAJz

# **Importing libraries**
"""

import pandas as pd                # for analys part and manuplation
import matplotlib.pyplot as plt    # used to create plots
import seaborn as sns              # for data visualization and exploratory 
import numpy as np                 # to perform mathematical operation

"""# **Explore and Visualize the features**

# **Loading the dataset**
"""

df=pd.read_csv('/content/Bank dataset.csv')
df

"""# **Shows top 5 records**"""

df.head(5)

"""# **Shows no. of Records and Attributes**"""

df.shape

"""# **Checks null values**"""

df.isnull().sum().sum()

"""# **Shows datatype and null values present for all columns**"""

df.info()

"""# **Shows no.of unique values per column**"""

for column in df.columns:
    print(column,df[column].nunique())

"""# **Shows statistical summary for numerical columns**"""

df.describe()

"""Transpose of num att output"""

num = round(df.describe()).T
num

"""ABOve result extract into excel"""

num.to_excel("Numerical attributes.xls")

"""# **Data Preprocessing: Label Encoder**

# **Converts categorical columns to numeric format**
"""

from sklearn.preprocessing import LabelEncoder
le=LabelEncoder()
df['n_deposit']=le.fit_transform(df['deposit'])

df

"""# **Deleted 2 columns from dataset**"""

df.drop(['deposit','pdays'],axis=1,inplace=True)
df

"""# **Checks no. of values in deposit column**"""

df.n_deposit.value_counts()

"""# **Shows unique values for all columns**"""

for col in df.select_dtypes(include='object').columns:
  print(col)
  print(df[col].unique())

"""# **Data Visualization**"""



#client with job profile Visualization
sns.countplot(y='job',data=df)
#plt.savefig('Client vs job.jpg')

"""# Client with job type as management records are high and housemaid and unknown are very less"""

sns.countplot(x= 'housing', hue = 'marital', data = df)
#plt.savefig('housing vs marital.jpg');

"""# Majority of the customers are married followed by single and divorced."""

sns.countplot(y='education',data=df)
#plt.savefig('client vs education.jpg')

"""# Client whose's education background is secondary are in high numbers."""

sns.countplot(x = 'month', hue = 'education', data = df)
#plt.savefig('month  vs education.jpg');

"""# In May month, customer takes highest number of secondary education

# **Plotting pie chart**
"""

countyes = df.default[df['default']=="yes"].count()
countno = df.default[df['default']=="no"].count()

print("ertyuiki",countyes,"ertyuhgfghjhg",countno)
labels = ['yes', 'no']
slices = [countyes,countno]
explode = [0.1, 0]

plt.pie(slices, labels=labels, explode=explode, shadow = True,
               startangle= -40, autopct='%1.1f%%',
          wedgeprops={'edgecolor':'black'})
plt.axis('equal')
plt.title("Banking")
plt.legend()
plt.tight_layout()
#plt.savefig('Banking.jpg')
plt.show()

"""# Client with housing loan, only 168 records corresponding to 'Yes' and 10994 to 'No'."""

import plotly
import plotly.graph_objs as go
from plotly.offline import download_plotlyjs, init_notebook_mode, iplot, plot
init_notebook_mode(connected=True)

df['n_loan']=le.fit_transform(df['loan'])

df

"""# **Question 1. To cumulate that how many customers taking loan according to their education level?**"""

plt.figure(figsize=(10,6))
sns.barplot(data=df, x='education', y='n_loan',palette='RdGy')
plt.xlabel("education")
plt.ylabel("loan")
plt.title(" loan by education")
#plt.savefig('Loan by education.jpg')
plt.show()

"""## Secondary education taking the highest number of loan

# **Question 2 :-Do young customer book more TDs or older generation?**
"""

pd.crosstab(df.age,df.n_deposit)

"""## Young Customer deposit more tds as compare to older

# **Question3:Use Box Plot to compare the age of customers for the top 5 of the most common employment forms**
"""

top_jobs = (df.job.value_counts().sort_values(ascending=False).head(5).index.values)
sns.boxplot(y="job", x="age", data=df[df.job.isin(top_jobs)], orient="h")
#plt.savefig('age vs job.jpg')

"""# The plot shows that among the top-5 client categories, the most senior customers represent the management, and the largest number of outliers is among the admin. and technician.

# **Question4: To calculate which month customer deposit maximum amount of money?**
"""

sns.set_theme(style='darkgrid')
sns.set(rc = {'figure.figsize':(6, 5)})
month = sns.countplot(x="month", data = df, hue = "n_deposit", order = df["month"].value_counts().index)
month.tick_params(axis='x', rotation=60)
plt.title("Bivariate analysis of the relationship between 'month' and 'n_deposit'")
#plt.savefig('Month vs n_deposit.jpg')
plt.show()

"""# May got an slightly more subscribers than the other months. Regardless how many people is contacted the subscription average is almost the same with the exception of December and January. These months were got the fewest subscriptions. One possible reasons could be the fact the people go for holidays. (In the Americas people are used to take holidays in this period of the year)

# **Applying label encoder on categorical columns**
"""

df['n_job']=le.fit_transform(df['job'])
df['n_marital']=le.fit_transform(df['marital'])
df['n_education']=le.fit_transform(df['education'])
df['n_loan']=le.fit_transform(df['loan'])
df['n_contact']=le.fit_transform(df['contact'])
df['n_month']=le.fit_transform(df['month'])
df['n_poutcome']=le.fit_transform(df['poutcome'])
df['n1_deposit']=df['n_deposit']

df.drop(['n_deposit'],axis=1,inplace=True)
df

df.drop(['job','month','marital','education','default','housing','loan','contact','poutcome'],axis=1,inplace=True)

df.head()

"""# **Shows all unique values per column**"""

for col in df.select_dtypes(include='int64').columns:
  print(col)
  print(df[col].unique())

df.describe()

df_1 = df

df_1.n1_deposit.value_counts()

"""# **Correlation Matrix**


"""

plt.figure(figsize=(20,20))
sns.heatmap(df_1.corr(),annot =True)
#plt.savefig('correlation.jpg')

"""# Duration(0.45) is highly and more positive corelated with n1_deposit.
# "campaign" is the most negative correlated feature to n1_deposit
# "n_jobs" and "n_material" and "n_education"are positive correlated to each other
"""

df_1

x=df_1.drop(['n1_deposit','age','day','n_job','n_marital','n_month','n_poutcome'],axis=1).values
print(x)
y=df_1['n1_deposit'].values
print(y)

y=df_1["n1_deposit"]

print(y)

x = df.iloc[:,:-1]
y = df.iloc[:,-1]

""" Train- Test Split method"""

from sklearn.model_selection import train_test_split

"""** divide 4 parts train-test**"""

x_train, x_test, y_train, y_test = train_test_split(x,y,test_size=0.30,random_state=3)

"""# **Summarize class distribution(imbalance target variable)**"""

print("Before oversampling:")
y_train.value_counts()

"""# **Define oversampling strategy**"""

!pip install imblearn

from imblearn.over_sampling import RandomOverSampler

oversample = RandomOverSampler(sampling_strategy='minority')

"""# **Fit and apply  the transform**"""

x_train_over, y_train_over = oversample.fit_resample(x_train, y_train)

print("after oversampling:")
y_train_over.value_counts()

from sklearn.preprocessing import StandardScaler
std_model=StandardScaler()
x_train_std_features=std_model.fit_transform(x_train_over)
x_test_std_features=std_model.transform(x_test)

"""# **Modelling**"""

from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.naive_bayes import GaussianNB
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report,confusion_matrix,accuracy_score
from sklearn import metrics

x_train.shape

x_test.shape

"""# **Model Building(Logistic Regression)**"""

from sklearn.linear_model import LogisticRegression
modelreg=LogisticRegression()
modelreg.fit(x_train_over,y_train_over)
ypred=modelreg.predict(x_test)
cf_matrix_logistic = confusion_matrix(y_test,ypred)
LR_accuracy =metrics.accuracy_score(y_test, ypred)*100
print("Accuracy:",round(LR_accuracy,0),"%")

"""# **Model Building(KNeighborsClassifier)**"""

from sklearn.neighbors import KNeighborsClassifier
KNN_model = KNeighborsClassifier(n_neighbors = 5, metric = 'minkowski', p = 2)
KNN_model.fit(x_train_over, y_train_over)
y_predicted_KNN = KNN_model.predict(x_test)
KNN_accuracy = metrics.accuracy_score(y_test, y_predicted_KNN) *100
print("Accuracy:",round(KNN_accuracy,0),"%")

"""# **Model Building(Naive Bayes)**"""

from sklearn.naive_bayes import GaussianNB
naive_bayes_model= GaussianNB()
naive_bayes_model.fit(x_train_over, y_train_over)
y_predicted_naive = naive_bayes_model.predict(x_test_std_features)
naive_bayes_model.score(x_test,y_test)
NB_accuracy = metrics.accuracy_score(y_test, y_predicted_naive) *100
print("Accuracy:",round(NB_accuracy,0),"%")

"""# **Model Building(Random Forest Classifier)**"""

from sklearn.ensemble import RandomForestClassifier
randomforest_model= RandomForestClassifier(n_estimators = 10, criterion = 'entropy')
randomforest_model.fit(x_train_over, y_train_over)
y_predicted_randomforest = randomforest_model.predict(x_test)
RFC_accuracy = metrics.accuracy_score(y_test,y_predicted_randomforest) * 100
print("Accuracy:",round(RFC_accuracy,0),"%")

"""# **Comparing The Accuracies of Models**"""

labels =["Logistic Regression", "KNN", "Naive Bayes", "Random Forest"]
x = [LR_accuracy,KNN_accuracy,NB_accuracy,RFC_accuracy]
eval_frame=pd.DataFrame()
eval_frame['Model']=labels
eval_frame['Train_test_split'] = x

eval_frame.to_csv("Train_test_split")
eval_frame

"""# **Confusion matrix corresponding to Random Forest Classifier Mode**"""

cf_matrix_RFC = confusion_matrix(y_test, y_predicted_randomforest)
cf_matrix_RFC

"""#visualization of confusion matrix"""

from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_predicted_randomforest )
plt.figure(figsize=(10,7))
ax=sns.heatmap(cm/np.sum(cm),annot=True,fmt='.2%',cmap="Blues")
ax.set_title('Confusion Matrix corresponding to Random Forest Classifier algorithm \n')
ax.set_xlabel("\nPredicted Value")
ax.set_ylabel("Actual Values")

from sklearn.metrics import RocCurveDisplay, roc_auc_score

from sklearn import metrics
randomforest_model.fit(x_train_over, y_train_over)
metrics.plot_roc_curve(randomforest_model, x_test, y_test)
plt.plot([0, 1], [0, 1], 'g--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.0])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve')
plt.savefig("ROC Curev.png")
plt.show()

"""#Classification report"""

print(classification_report(y_test, y_predicted_randomforest ))